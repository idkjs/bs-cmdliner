// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var Char = require("bs-platform/lib/js/char.js");
var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

var Cmap = $$Map.Make({
      compare: Char.compare
    });

var empty_succs = Cmap.empty;

var empty = {
  v: /* Nil */1,
  succs: empty_succs
};

function is_empty(t) {
  return Caml_obj.caml_equal(t, empty);
}

function add(t, k, d) {
  var loop = function (t, k, len, i, d, pre_d) {
    if (i === len) {
      var t$prime_v = {
        TAG: /* Key */1,
        _0: d
      };
      var t$prime_succs = t.succs;
      var t$prime = {
        v: t$prime_v,
        succs: t$prime_succs
      };
      var old = t.v;
      if (typeof old === "number" || old.TAG !== /* Key */1) {
        return {
                NAME: "New",
                VAL: t$prime
              };
      } else {
        return {
                NAME: "Replaced",
                VAL: [
                  old._0,
                  t$prime
                ]
              };
      }
    }
    var v = t.v;
    var v$1;
    v$1 = typeof v === "number" ? (
        v === /* Amb */0 ? /* Amb */0 : pre_d
      ) : (
        v.TAG ? v : /* Amb */0
      );
    var t$prime$1;
    try {
      t$prime$1 = Curry._2(Cmap.find, Caml_string.get(k, i), t.succs);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        t$prime$1 = empty;
      } else {
        throw exn;
      }
    }
    var match = loop(t$prime$1, k, len, i + 1 | 0, d, pre_d);
    if (match.NAME === "New") {
      return {
              NAME: "New",
              VAL: {
                v: v$1,
                succs: Curry._3(Cmap.add, Caml_string.get(k, i), match.VAL, t.succs)
              }
            };
    }
    var match$1 = match.VAL;
    return {
            NAME: "Replaced",
            VAL: [
              match$1[0],
              {
                v: v$1,
                succs: Curry._3(Cmap.add, Caml_string.get(k, i), match$1[1], t.succs)
              }
            ]
          };
  };
  return loop(t, k, k.length, 0, d, {
              TAG: /* Pre */0,
              _0: d
            });
}

function find_node(t, k) {
  var _t = t;
  var len = k.length;
  var _i = 0;
  while(true) {
    var i = _i;
    var t$1 = _t;
    if (i === len) {
      return t$1;
    }
    _i = i + 1 | 0;
    _t = Curry._2(Cmap.find, Caml_string.get(k, i), t$1.succs);
    continue ;
  };
}

function find(t, k) {
  try {
    var match = find_node(t, k).v;
    if (typeof match === "number") {
      if (match !== 0) {
        return "Not_found";
      } else {
        return "Ambiguous";
      }
    } else {
      return {
              NAME: "Ok",
              VAL: match._0
            };
    }
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return "Not_found";
    }
    throw exn;
  }
}

function ambiguities(t, p) {
  try {
    var t$1 = find_node(t, p);
    var match = t$1.v;
    if (typeof match !== "number") {
      return /* [] */0;
    }
    if (match !== 0) {
      return /* [] */0;
    }
    var add_char = function (s, c) {
      return s + $$String.make(1, c);
    };
    var rem_char = function (s) {
      return $$String.sub(s, 0, s.length - 1 | 0);
    };
    var to_list = function (m) {
      return Curry._3(Cmap.fold, (function (k, t, acc) {
                    return {
                            hd: [
                              k,
                              t
                            ],
                            tl: acc
                          };
                  }), m, /* [] */0);
    };
    var _acc = /* [] */0;
    var _p = p;
    var _param = {
      hd: to_list(t$1.succs),
      tl: /* [] */0
    };
    while(true) {
      var param = _param;
      var p$1 = _p;
      var acc = _acc;
      if (param) {
        var match$1 = param.hd;
        if (match$1) {
          var match$2 = match$1.hd;
          var t$2 = match$2[1];
          var p$prime = add_char(p$1, match$2[0]);
          var match$3 = t$2.v;
          var acc$prime;
          if (typeof match$3 === "number") {
            if (match$3 === /* Amb */0) {
              acc$prime = acc;
            } else {
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "cmdliner_trie.ml",
                      69,
                      21
                    ],
                    Error: new Error()
                  };
            }
          } else {
            acc$prime = match$3.TAG ? ({
                  hd: p$prime,
                  tl: acc
                }) : acc;
          }
          _param = {
            hd: to_list(t$2.succs),
            tl: {
              hd: match$1.tl,
              tl: param.tl
            }
          };
          _p = p$prime;
          _acc = acc$prime;
          continue ;
        }
        var rest = param.tl;
        if (!rest) {
          return acc;
        }
        _param = rest;
        _p = rem_char(p$1);
        continue ;
      }
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "cmdliner_trie.ml",
              74,
              16
            ],
            Error: new Error()
          };
    };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return /* [] */0;
    }
    throw exn;
  }
}

function of_list(l) {
  var add$1 = function (t, param) {
    var match = add(t, param[0], param[1]);
    if (match.NAME === "New") {
      return match.VAL;
    } else {
      return match.VAL[1];
    }
  };
  return List.fold_left(add$1, empty, l);
}

exports.empty = empty;
exports.is_empty = is_empty;
exports.add = add;
exports.find = find;
exports.ambiguities = ambiguities;
exports.of_list = of_list;
/* Cmap Not a pure module */
