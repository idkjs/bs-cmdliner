// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Sys = require("bs-platform/lib/js/sys.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Caml_sys = require("bs-platform/lib/js/caml_sys.js");
var Printexc = require("bs-platform/lib/js/printexc.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Cmdliner_arg = require("./cmdliner_arg.bs.js");
var Cmdliner_msg = require("./cmdliner_msg.bs.js");
var Cmdliner_base = require("./cmdliner_base.bs.js");
var Cmdliner_info = require("./cmdliner_info.bs.js");
var Cmdliner_term = require("./cmdliner_term.bs.js");
var Cmdliner_trie = require("./cmdliner_trie.bs.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Cmdliner_cline = require("./cmdliner_cline.bs.js");
var Cmdliner_docgen = require("./cmdliner_docgen.bs.js");
var Cmdliner_manpage = require("./cmdliner_manpage.bs.js");
var Cmdliner_suggest = require("./cmdliner_suggest.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function ret(param) {
  var v = param[1];
  return [
          param[0],
          (function (ei, cl) {
              var err = Curry._2(v, ei, cl);
              if (err.TAG) {
                return err;
              }
              var err$1 = err._0;
              var variant = err$1.NAME;
              if (variant === "Help" || variant === "Error") {
                return {
                        TAG: /* Error */1,
                        _0: err$1
                      };
              } else {
                return {
                        TAG: /* Ok */0,
                        _0: err$1.VAL
                      };
              }
            })
        ];
}

function term_result($staropt$star, param) {
  var v = param[1];
  var usage = $staropt$star !== undefined ? $staropt$star : false;
  return [
          param[0],
          (function (ei, cl) {
              var ok = Curry._2(v, ei, cl);
              if (ok.TAG) {
                return ok;
              }
              var ok$1 = ok._0;
              if (ok$1.TAG) {
                return {
                        TAG: /* Error */1,
                        _0: {
                          NAME: "Error",
                          VAL: [
                            usage,
                            ok$1._0.VAL
                          ]
                        }
                      };
              } else {
                return ok$1;
              }
            })
        ];
}

function cli_parse_result(param) {
  var v = param[1];
  return [
          param[0],
          (function (ei, cl) {
              var ok = Curry._2(v, ei, cl);
              if (ok.TAG) {
                return ok;
              }
              var ok$1 = ok._0;
              if (ok$1.TAG) {
                return {
                        TAG: /* Error */1,
                        _0: {
                          NAME: "Parse",
                          VAL: ok$1._0.VAL
                        }
                      };
              } else {
                return ok$1;
              }
            })
        ];
}

var main_name_0 = Cmdliner_info.Args.empty;

function main_name_1(ei, param) {
  return {
          TAG: /* Ok */0,
          _0: Cmdliner_info.term_name(Cmdliner_info.eval_main(ei))
        };
}

var main_name = [
  main_name_0,
  main_name_1
];

var choice_name = Cmdliner_info.term_name;

var choice_names_0 = Cmdliner_info.Args.empty;

function choice_names_1(ei, param) {
  return {
          TAG: /* Ok */0,
          _0: List.rev_map(choice_name, Cmdliner_info.eval_choices(ei))
        };
}

var choice_names = [
  choice_names_0,
  choice_names_1
];

function with_used_args(param) {
  var v = param[1];
  var al = param[0];
  return [
          al,
          (function (ei, cl) {
              var x = Curry._2(v, ei, cl);
              if (x.TAG) {
                return x;
              }
              var actual_args = function (arg_info, acc) {
                var args = Cmdliner_cline.actual_args(cl, arg_info);
                return List.rev_append(args, acc);
              };
              var used = List.rev(Curry._3(Cmdliner_info.Args.fold, actual_args, al, /* [] */0));
              return {
                      TAG: /* Ok */0,
                      _0: [
                        x._0,
                        used
                      ]
                    };
            })
        ];
}

var default_error_exits_0 = Cmdliner_info.exit(undefined, "on command line parsing errors.", undefined, 124);

var default_error_exits_1 = {
  hd: Cmdliner_info.exit(undefined, "on unexpected internal errors (bugs).", undefined, 125),
  tl: /* [] */0
};

var default_error_exits = {
  hd: default_error_exits_0,
  tl: default_error_exits_1
};

var default_exits_0 = Cmdliner_info.exit(undefined, "on success.", undefined, 0);

var default_exits = {
  hd: default_exits_0,
  tl: default_error_exits
};

var partial_arg = Caml_option.some(Cmdliner_info.Args.empty);

function info(param, param$1, param$2, param$3, param$4, param$5, param$6, param$7, param$8) {
  return Cmdliner_info.term(partial_arg, param, param$1, param$2, param$3, param$4, param$5, param$6, param$7, param$8);
}

var name = Cmdliner_info.term_name;

function err_multi_cmd_def(name, param, param$1) {
  return Cmdliner_base.err_multi_def("command", name, Cmdliner_info.term_doc, param[0], param$1[0]);
}

function add_stdopts(ei) {
  var docs = Cmdliner_info.term_stdopts_docs(Cmdliner_info.eval_term(ei));
  var match = Cmdliner_info.term_version(Cmdliner_info.eval_main(ei));
  var match$1;
  if (match !== undefined) {
    var vers = Cmdliner_arg.stdopt_version(docs);
    match$1 = [
      vers[0],
      vers
    ];
  } else {
    match$1 = [
      Cmdliner_info.Args.empty,
      undefined
    ];
  }
  var help = Cmdliner_arg.stdopt_help(docs);
  var args = Curry._2(Cmdliner_info.Args.union, match$1[0], help[0]);
  var term = Cmdliner_info.term_add_args(Cmdliner_info.eval_term(ei), args);
  return [
          help,
          match$1[1],
          Cmdliner_info.eval_with_term(ei, term)
        ];
}

function run($$catch, ei, cl, f) {
  try {
    return Curry._2(f, ei, cl);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if ($$catch) {
      var bt = Printexc.get_raw_backtrace(undefined);
      return {
              TAG: /* Error */1,
              _0: {
                NAME: "Exn",
                VAL: [
                  exn,
                  bt
                ]
              }
            };
    }
    throw exn;
  }
}

function try_eval_stdopts($$catch, ei, cl, help, version) {
  var err = run($$catch, ei, cl, help[1]);
  if (err.TAG) {
    return err;
  }
  var fmt = err._0;
  if (fmt !== undefined) {
    return {
            TAG: /* Error */1,
            _0: {
              NAME: "Std_help",
              VAL: fmt
            }
          };
  }
  if (version === undefined) {
    return ;
  }
  var err$1 = run($$catch, ei, cl, version[1]);
  if (err$1.TAG) {
    return err$1;
  } else if (err$1._0) {
    return {
            TAG: /* Error */1,
            _0: "Std_version"
          };
  } else {
    return ;
  }
}

function term_eval($$catch, ei, f, args) {
  var match = add_stdopts(ei);
  var ei$1 = match[2];
  var version = match[1];
  var help = match[0];
  var term_args = Cmdliner_info.term_args(Cmdliner_info.eval_term(ei$1));
  var cl = Cmdliner_cline.create(undefined, term_args, args);
  var res;
  if (cl.TAG) {
    var match$1 = cl._0;
    var e = try_eval_stdopts($$catch, ei$1, match$1[1], help, version);
    res = e !== undefined ? e : ({
          TAG: /* Error */1,
          _0: {
            NAME: "Error",
            VAL: [
              true,
              match$1[0]
            ]
          }
        });
  } else {
    var cl$1 = cl._0;
    var e$1 = try_eval_stdopts($$catch, ei$1, cl$1, help, version);
    res = e$1 !== undefined ? e$1 : run($$catch, ei$1, cl$1, f);
  }
  return [
          ei$1,
          res
        ];
}

function do_help(help_ppf, err_ppf, ei, fmt, cmd) {
  var ei$1;
  if (cmd !== undefined) {
    try {
      var is_cmd = function (t) {
        return Cmdliner_info.term_name(t) === cmd;
      };
      var cmd$1 = List.find(is_cmd, Cmdliner_info.eval_choices(ei));
      ei$1 = Cmdliner_info.eval_with_term(ei, cmd$1);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        ei$1 = Pervasives.invalid_arg("Term error, help requested for unknown command " + cmd);
      } else {
        throw exn;
      }
    }
  } else {
    ei$1 = Cmdliner_info.eval_with_term(ei, Cmdliner_info.eval_main(ei));
  }
  var match = add_stdopts(ei$1);
  return Cmdliner_docgen.pp_man(err_ppf, fmt, help_ppf, match[2]);
}

function do_result(help_ppf, err_ppf, ei, v) {
  if (!v.TAG) {
    return {
            NAME: "Ok",
            VAL: v._0
          };
  }
  var res = v._0;
  if (typeof res === "string") {
    Cmdliner_msg.pp_version(help_ppf, ei);
    return "Version";
  }
  var variant = res.NAME;
  if (variant === "Std_help") {
    Cmdliner_docgen.pp_man(err_ppf, res.VAL, help_ppf, ei);
    return "Help";
  }
  if (variant === "Exn") {
    var match = res.VAL;
    Cmdliner_msg.pp_backtrace(err_ppf, ei, match[0], match[1]);
    return {
            NAME: "Error",
            VAL: "Exn"
          };
  }
  if (variant === "Error") {
    var match$1 = res.VAL;
    var err = match$1[1];
    if (match$1[0]) {
      Cmdliner_msg.pp_err_usage(err_ppf, ei, true, err);
    } else {
      Cmdliner_msg.pp_err(err_ppf, ei, err);
    }
    return {
            NAME: "Error",
            VAL: "Term"
          };
  }
  if (variant === "Help") {
    var match$2 = res.VAL;
    do_help(help_ppf, err_ppf, ei, match$2[0], match$2[1]);
    return "Help";
  }
  Cmdliner_msg.pp_err_usage(err_ppf, ei, false, res.VAL);
  return {
          NAME: "Error",
          VAL: "Parse"
        };
}

function env_default(v) {
  try {
    return Caml_sys.caml_sys_getenv(v);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Not_found") {
      return ;
    }
    throw exn;
  }
}

function remove_exec(argv) {
  try {
    return List.tl($$Array.to_list(argv));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Failure") {
      return Pervasives.invalid_arg("argv array must have at least one element");
    }
    throw exn;
  }
}

function $$eval($staropt$star, $staropt$star$1, $staropt$star$2, $staropt$star$3, $staropt$star$4, param) {
  var match = param[0];
  var help_ppf = $staropt$star !== undefined ? Caml_option.valFromOption($staropt$star) : Format.std_formatter;
  var err_ppf = $staropt$star$1 !== undefined ? Caml_option.valFromOption($staropt$star$1) : Format.err_formatter;
  var $$catch = $staropt$star$2 !== undefined ? $staropt$star$2 : true;
  var env = $staropt$star$3 !== undefined ? $staropt$star$3 : env_default;
  var argv = $staropt$star$4 !== undefined ? $staropt$star$4 : Sys.argv;
  var term = Cmdliner_info.term_add_args(param[1], match[0]);
  var ei = Cmdliner_info.$$eval(term, term, /* [] */0, env);
  var args = remove_exec(argv);
  var match$1 = term_eval($$catch, ei, match[1], args);
  return do_result(help_ppf, err_ppf, match$1[0], match$1[1]);
}

function choose_term(main, choices, args) {
  if (!args) {
    return {
            TAG: /* Ok */0,
            _0: [
              main,
              /* [] */0
            ]
          };
  }
  var maybe = args.hd;
  if (maybe.length > 1 && Caml_string.get(maybe, 0) === /* "-" */45) {
    return {
            TAG: /* Ok */0,
            _0: [
              main,
              args
            ]
          };
  }
  var add = function (acc, c) {
    var name = Cmdliner_info.term_name(c[0]);
    var match = Cmdliner_trie.add(acc, name, c);
    if (match.NAME === "New") {
      return match.VAL;
    } else {
      return Pervasives.invalid_arg(err_multi_cmd_def(name, c, match.VAL[0]));
    }
  };
  var index = List.fold_left(add, Cmdliner_trie.empty, choices);
  var match = Cmdliner_trie.find(index, maybe);
  if (typeof match !== "string") {
    return {
            TAG: /* Ok */0,
            _0: [
              match.VAL,
              args.tl
            ]
          };
  }
  if (match === "Ambiguous") {
    var ambs = Cmdliner_trie.ambiguities(index, maybe);
    var ambs$1 = List.sort(Caml_primitive.caml_string_compare, ambs);
    return {
            TAG: /* Error */1,
            _0: Cmdliner_base.err_ambiguous("command", maybe, ambs$1)
          };
  }
  var all = Cmdliner_trie.ambiguities(index, "");
  var hints = Cmdliner_suggest.value(maybe, all);
  return {
          TAG: /* Error */1,
          _0: Cmdliner_base.err_unknown(hints, "command", maybe)
        };
}

function eval_choice(help_ppfOpt, err_ppfOpt, catchOpt, envOpt, argvOpt, main, choices) {
  var help_ppf = help_ppfOpt !== undefined ? Caml_option.valFromOption(help_ppfOpt) : Format.std_formatter;
  var err_ppf = err_ppfOpt !== undefined ? Caml_option.valFromOption(err_ppfOpt) : Format.err_formatter;
  var $$catch = catchOpt !== undefined ? catchOpt : true;
  var env = envOpt !== undefined ? envOpt : env_default;
  var argv = argvOpt !== undefined ? argvOpt : Sys.argv;
  var to_term_f = function (param) {
    var match = param[0];
    return [
            Cmdliner_info.term_add_args(param[1], match[0]),
            match[1]
          ];
  };
  var choices_f = List.rev_map(to_term_f, choices);
  var main_f = to_term_f(main);
  var choices$1 = List.rev_map((function (prim) {
          return prim[0];
        }), choices_f);
  var main$1 = main_f[0];
  var err = choose_term(main_f, choices_f, remove_exec(argv));
  if (err.TAG) {
    var ei = Cmdliner_info.$$eval(main$1, main$1, choices$1, env);
    Cmdliner_msg.pp_err_usage(err_ppf, ei, false, err._0);
    return {
            NAME: "Error",
            VAL: "Parse"
          };
  }
  var match = err._0;
  var match$1 = match[0];
  var ei$1 = Cmdliner_info.$$eval(match$1[0], main$1, choices$1, env);
  var match$2 = term_eval($$catch, ei$1, match$1[1], match[1]);
  return do_result(help_ppf, err_ppf, match$2[0], match$2[1]);
}

function eval_peek_opts($staropt$star, $staropt$star$1, $staropt$star$2, param) {
  var version_opt = $staropt$star !== undefined ? $staropt$star : false;
  var env = $staropt$star$1 !== undefined ? $staropt$star$1 : env_default;
  var argv = $staropt$star$2 !== undefined ? $staropt$star$2 : Sys.argv;
  var version = version_opt ? "dummy" : undefined;
  var term = Cmdliner_info.term(Caml_option.some(param[0]), undefined, undefined, undefined, undefined, undefined, undefined, undefined, version, "dummy");
  var ei = Cmdliner_info.$$eval(term, term, /* [] */0, env);
  var f = param[1];
  var args = remove_exec(argv);
  var match = add_stdopts(ei);
  var ei$1 = match[2];
  var version$1 = match[1];
  var help = match[0];
  var term_args = Cmdliner_info.term_args(Cmdliner_info.eval_term(ei$1));
  var cl = Cmdliner_cline.create(true, term_args, args);
  var match$1;
  if (cl.TAG) {
    var match$2 = cl._0;
    var e = try_eval_stdopts(true, ei$1, match$2[1], help, version$1);
    match$1 = e !== undefined ? [
        undefined,
        e
      ] : [
        undefined,
        {
          TAG: /* Error */1,
          _0: {
            NAME: "Error",
            VAL: [
              true,
              match$2[0]
            ]
          }
        }
      ];
  } else {
    var cl$1 = cl._0;
    var ret = run(true, ei$1, cl$1, f);
    var v;
    v = ret.TAG ? undefined : Caml_option.some(ret._0);
    var e$1 = try_eval_stdopts(true, ei$1, cl$1, help, version$1);
    match$1 = e$1 !== undefined ? [
        v,
        e$1
      ] : [
        v,
        ret
      ];
  }
  var ret$1 = match$1[1];
  var ret$2;
  if (ret$1.TAG) {
    var match$3 = ret$1._0;
    if (typeof match$3 === "string") {
      ret$2 = "Version";
    } else {
      var variant = match$3.NAME;
      ret$2 = variant === "Help" || variant === "Std_help" ? "Help" : (
          variant === "Exn" ? ({
                NAME: "Error",
                VAL: "Exn"
              }) : (
              variant === "Error" ? ({
                    NAME: "Error",
                    VAL: "Term"
                  }) : ({
                    NAME: "Error",
                    VAL: "Parse"
                  })
            )
        );
    }
  } else {
    ret$2 = {
      NAME: "Ok",
      VAL: ret$1._0
    };
  }
  return [
          match$1[0],
          ret$2
        ];
}

function exit_status_of_result($staropt$star, param) {
  var term_err = $staropt$star !== undefined ? $staropt$star : 1;
  if (typeof param === "string") {
    return 0;
  }
  if (param.NAME !== "Error") {
    return 0;
  }
  var match = param.VAL;
  if (match === "Exn") {
    return 125;
  } else if (match === "Term") {
    return term_err;
  } else {
    return 124;
  }
}

function exit_status_of_status_result(term_err, r) {
  if (typeof r === "string" || r.NAME !== "Ok") {
    return exit_status_of_result(term_err, r);
  } else {
    return r.VAL;
  }
}

function exit(term_err, r) {
  return Pervasives.exit(exit_status_of_result(term_err, r));
}

function exit_status(term_err, r) {
  return Pervasives.exit(exit_status_of_status_result(term_err, r));
}

var Manpage = {
  $$escape: Cmdliner_manpage.$$escape,
  s_name: Cmdliner_manpage.s_name,
  s_synopsis: Cmdliner_manpage.s_synopsis,
  s_description: Cmdliner_manpage.s_description,
  s_commands: Cmdliner_manpage.s_commands,
  s_arguments: Cmdliner_manpage.s_arguments,
  s_options: Cmdliner_manpage.s_options,
  s_common_options: Cmdliner_manpage.s_common_options,
  s_exit_status: Cmdliner_manpage.s_exit_status,
  s_environment: Cmdliner_manpage.s_environment,
  s_environment_intro: Cmdliner_manpage.s_environment_intro,
  s_files: Cmdliner_manpage.s_files,
  s_bugs: Cmdliner_manpage.s_bugs,
  s_examples: Cmdliner_manpage.s_examples,
  s_authors: Cmdliner_manpage.s_authors,
  s_see_also: Cmdliner_manpage.s_see_also,
  print: Cmdliner_manpage.print
};

var Term = {
  $$const: Cmdliner_term.$$const,
  pure: Cmdliner_term.$$const,
  man_format: Cmdliner_arg.man_format,
  $: Cmdliner_term.app,
  app: Cmdliner_term.app,
  ret: ret,
  term_result: term_result,
  cli_parse_result: cli_parse_result,
  main_name: main_name,
  choice_names: choice_names,
  with_used_args: with_used_args,
  exit_info: Cmdliner_info.exit,
  default_exits: default_exits,
  default_error_exits: default_error_exits,
  env_info: Cmdliner_info.env,
  info: info,
  name: name,
  $$eval: $$eval,
  eval_choice: eval_choice,
  eval_peek_opts: eval_peek_opts,
  exit_status_success: 0,
  exit_status_cli_error: 124,
  exit_status_internal_error: 125,
  exit_status_of_result: exit_status_of_result,
  exit_status_of_status_result: exit_status_of_status_result,
  exit: exit,
  exit_status: exit_status
};

var Arg = {
  conv: Cmdliner_arg.conv,
  pconv: Cmdliner_arg.pconv,
  conv_parser: Cmdliner_arg.conv_parser,
  conv_printer: Cmdliner_arg.conv_printer,
  conv_docv: Cmdliner_arg.conv_docv,
  parser_of_kind_of_string: Cmdliner_arg.parser_of_kind_of_string,
  some: Cmdliner_arg.some,
  env_var: Cmdliner_arg.env_var,
  info: Cmdliner_arg.info,
  $amp: Cmdliner_arg.$amp,
  flag: Cmdliner_arg.flag,
  flag_all: Cmdliner_arg.flag_all,
  vflag: Cmdliner_arg.vflag,
  vflag_all: Cmdliner_arg.vflag_all,
  opt: Cmdliner_arg.opt,
  opt_all: Cmdliner_arg.opt_all,
  pos: Cmdliner_arg.pos,
  pos_all: Cmdliner_arg.pos_all,
  pos_left: Cmdliner_arg.pos_left,
  pos_right: Cmdliner_arg.pos_right,
  value: Cmdliner_arg.value,
  required: Cmdliner_arg.required,
  non_empty: Cmdliner_arg.non_empty,
  last: Cmdliner_arg.last,
  man_format: Cmdliner_arg.man_format,
  bool: Cmdliner_arg.bool,
  $$char: Cmdliner_arg.$$char,
  $$int: Cmdliner_arg.$$int,
  nativeint: Cmdliner_arg.nativeint,
  int32: Cmdliner_arg.int32,
  int64: Cmdliner_arg.int64,
  $$float: Cmdliner_arg.$$float,
  string: Cmdliner_arg.string,
  $$enum: Cmdliner_arg.$$enum,
  file: Cmdliner_arg.file,
  dir: Cmdliner_arg.dir,
  non_dir_file: Cmdliner_arg.non_dir_file,
  list: Cmdliner_arg.list,
  array: Cmdliner_arg.array,
  pair: Cmdliner_arg.pair,
  t2: Cmdliner_arg.t2,
  t3: Cmdliner_arg.t3,
  t4: Cmdliner_arg.t4,
  doc_quote: Cmdliner_arg.doc_quote,
  doc_alts: Cmdliner_arg.doc_alts,
  doc_alts_enum: Cmdliner_arg.doc_alts_enum
};

exports.Manpage = Manpage;
exports.Term = Term;
exports.Arg = Arg;
/* default_error_exits Not a pure module */
