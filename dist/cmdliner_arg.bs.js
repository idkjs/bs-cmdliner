// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Format = require("bs-platform/lib/js/format.js");
var Printf = require("bs-platform/lib/js/printf.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Cmdliner_msg = require("./cmdliner_msg.bs.js");
var Cmdliner_base = require("./cmdliner_base.bs.js");
var Cmdliner_info = require("./cmdliner_info.bs.js");
var Cmdliner_cline = require("./cmdliner_cline.bs.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

function rev_compare(n0, n1) {
  return Caml_obj.caml_compare(n1, n0);
}

var err_not_opt = "Option argument without name";

var err_not_pos = "Positional argument with a name";

function doc_alts_enum(quoted, $$enum) {
  return Cmdliner_base.alts_str(quoted, List.map((function (prim) {
                    return prim[0];
                  }), $$enum));
}

function str_of_pp(pp, v) {
  Curry._2(pp, Format.str_formatter, v);
  return Format.flush_str_formatter(undefined);
}

function conv(docv, param) {
  var parse = param[0];
  var parse$1 = function (s) {
    var v = Curry._1(parse, s);
    if (v.TAG) {
      return {
              NAME: "Error",
              VAL: v._0.VAL
            };
    } else {
      return {
              NAME: "Ok",
              VAL: v._0
            };
    }
  };
  return [
          parse$1,
          param[1]
        ];
}

function pconv(docv, conv) {
  return conv;
}

function conv_parser(param, s) {
  var match = Curry._1(param[0], s);
  if (match.NAME === "Error") {
    return {
            TAG: /* Error */1,
            _0: {
              NAME: "Msg",
              VAL: match.VAL
            }
          };
  } else {
    return {
            TAG: /* Ok */0,
            _0: match.VAL
          };
  }
}

function conv_printer(param) {
  return param[1];
}

function conv_docv(param) {
  return "VALUE";
}

function err_invalid(s, kind) {
  return {
          NAME: "Msg",
          VAL: Curry._2(Printf.sprintf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "invalid value '",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: "', expected ",
                          _1: {
                            TAG: /* String */2,
                            _0: /* No_padding */0,
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "invalid value '%s', expected %s"
                  }), s, kind)
        };
}

function parser_of_kind_of_string(kind, k_of_string, s) {
  var v = Curry._1(k_of_string, s);
  if (v !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(v)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: err_invalid(s, kind)
          };
  }
}

function $amp(f, x) {
  return Curry._1(f, x);
}

function parse_to_list(parser, s) {
  var e = Curry._1(parser, s);
  if (e.NAME === "Error") {
    return e;
  } else {
    return {
            NAME: "Ok",
            VAL: {
              hd: e.VAL,
              tl: /* [] */0
            }
          };
  }
}

function try_env(ei, a, parse, absent) {
  var env = Cmdliner_info.arg_env(a);
  if (env === undefined) {
    return {
            TAG: /* Ok */0,
            _0: absent
          };
  }
  var env$1 = Caml_option.valFromOption(env);
  var $$var = Cmdliner_info.env_var(env$1);
  var v = Cmdliner_info.eval_env_var(ei, $$var);
  if (v === undefined) {
    return {
            TAG: /* Ok */0,
            _0: absent
          };
  }
  var match = Curry._1(parse, v);
  if (match.NAME !== "Error") {
    return {
            TAG: /* Ok */0,
            _0: match.VAL
          };
  }
  var e = Cmdliner_msg.err_env_parse(env$1, match.VAL);
  return {
          TAG: /* Error */1,
          _0: {
            NAME: "Parse",
            VAL: e
          }
        };
}

var arg_to_args = Cmdliner_info.Args.singleton;

function list_to_args(f, l) {
  var add = function (acc, v) {
    return Curry._2(Cmdliner_info.Args.add, Curry._1(f, v), acc);
  };
  return List.fold_left(add, Cmdliner_info.Args.empty, l);
}

function flag(a) {
  if (Cmdliner_info.arg_is_pos(a)) {
    return Pervasives.invalid_arg(err_not_opt);
  }
  var convert = function (ei, cl) {
    var match = Cmdliner_cline.opt_arg(cl, a);
    if (!match) {
      return try_env(ei, a, Cmdliner_base.env_bool_parse, false);
    }
    var match$1 = match.hd;
    var v = match$1[2];
    var f = match$1[1];
    if (v !== undefined) {
      if (!match.tl) {
        var e = Cmdliner_msg.err_flag_value(f, v);
        return {
                TAG: /* Error */1,
                _0: {
                  NAME: "Parse",
                  VAL: e
                }
              };
      }
      
    } else if (!match.tl) {
      return {
              TAG: /* Ok */0,
              _0: true
            };
    }
    var e$1 = Cmdliner_msg.err_opt_repeated(f, match.tl.hd[1]);
    return {
            TAG: /* Error */1,
            _0: {
              NAME: "Parse",
              VAL: e$1
            }
          };
  };
  return [
          Curry._1(arg_to_args, a),
          convert
        ];
}

function flag_all(a) {
  if (Cmdliner_info.arg_is_pos(a)) {
    return Pervasives.invalid_arg(err_not_opt);
  }
  var a$1 = Cmdliner_info.arg_make_all_opts(a);
  var convert = function (ei, cl) {
    var l = Cmdliner_cline.opt_arg(cl, a$1);
    if (!l) {
      return try_env(ei, a$1, (function (param) {
                    return parse_to_list(Cmdliner_base.env_bool_parse, param);
                  }), /* [] */0);
    }
    try {
      var truth = function (param) {
        var v = param[2];
        if (v !== undefined) {
          return Pervasives.failwith(Cmdliner_msg.err_flag_value(param[1], v));
        } else {
          return true;
        }
      };
      return {
              TAG: /* Ok */0,
              _0: List.rev_map(truth, l)
            };
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === "Failure") {
        return {
                TAG: /* Error */1,
                _0: {
                  NAME: "Parse",
                  VAL: e._1
                }
              };
      }
      throw e;
    }
  };
  return [
          Curry._1(arg_to_args, a$1),
          convert
        ];
}

function vflag(v, l) {
  var convert = function (param, cl) {
    var aux = function (_fv, _param) {
      while(true) {
        var param = _param;
        var fv = _fv;
        if (!param) {
          if (fv !== undefined) {
            return fv[1];
          } else {
            return v;
          }
        }
        var rest = param.tl;
        var match = param.hd;
        var match$1 = Cmdliner_cline.opt_arg(cl, match[1]);
        if (match$1) {
          var match$2 = match$1.hd;
          var v$1 = match$2[2];
          var f = match$2[1];
          if (v$1 !== undefined) {
            if (!match$1.tl) {
              return Pervasives.failwith(Cmdliner_msg.err_flag_value(f, v$1));
            }
            
          } else if (!match$1.tl) {
            if (fv !== undefined) {
              return Pervasives.failwith(Cmdliner_msg.err_opt_repeated(fv[0], f));
            }
            _param = rest;
            _fv = [
              f,
              match[0]
            ];
            continue ;
          }
          return Pervasives.failwith(Cmdliner_msg.err_opt_repeated(match$1.tl.hd[1], f));
        }
        _param = rest;
        continue ;
      };
    };
    try {
      return {
              TAG: /* Ok */0,
              _0: aux(undefined, l)
            };
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === "Failure") {
        return {
                TAG: /* Error */1,
                _0: {
                  NAME: "Parse",
                  VAL: e._1
                }
              };
      }
      throw e;
    }
  };
  var flag = function (param) {
    var a = param[1];
    if (Cmdliner_info.arg_is_pos(a)) {
      return Pervasives.invalid_arg(err_not_opt);
    } else {
      return a;
    }
  };
  return [
          list_to_args(flag, l),
          convert
        ];
}

function vflag_all(v, l) {
  var convert = function (param, cl) {
    var aux = function (_acc, _param) {
      while(true) {
        var param = _param;
        var acc = _acc;
        if (!param) {
          if (acc === /* [] */0) {
            return v;
          } else {
            return List.rev_map((function (prim) {
                          return prim[1];
                        }), List.sort(rev_compare, acc));
          }
        }
        var rest = param.tl;
        var match = param.hd;
        var fv = match[0];
        var l = Cmdliner_cline.opt_arg(cl, match[1]);
        if (l) {
          var fval = (function(fv){
          return function fval(param) {
            var v = param[2];
            if (v !== undefined) {
              return Pervasives.failwith(Cmdliner_msg.err_flag_value(param[1], v));
            } else {
              return [
                      param[0],
                      fv
                    ];
            }
          }
          }(fv));
          _param = rest;
          _acc = List.rev_append(List.rev_map(fval, l), acc);
          continue ;
        }
        _param = rest;
        continue ;
      };
    };
    try {
      return {
              TAG: /* Ok */0,
              _0: aux(/* [] */0, l)
            };
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === "Failure") {
        return {
                TAG: /* Error */1,
                _0: {
                  NAME: "Parse",
                  VAL: e._1
                }
              };
      }
      throw e;
    }
  };
  var flag = function (param) {
    var a = param[1];
    if (Cmdliner_info.arg_is_pos(a)) {
      return Pervasives.invalid_arg(err_not_opt);
    } else {
      return Cmdliner_info.arg_make_all_opts(a);
    }
  };
  return [
          list_to_args(flag, l),
          convert
        ];
}

function parse_opt_value(parse, f, v) {
  var match = Curry._1(parse, v);
  if (match.NAME === "Error") {
    return Pervasives.failwith(Cmdliner_msg.err_opt_parse(f, match.VAL));
  } else {
    return match.VAL;
  }
}

function opt(vopt, param, v, a) {
  var print = param[1];
  var parse = param[0];
  if (Cmdliner_info.arg_is_pos(a)) {
    return Pervasives.invalid_arg(err_not_opt);
  }
  var absent = /* Val */{
    _0: {
      LAZY_DONE: false,
      VAL: (function () {
          return str_of_pp(print, v);
        })
    }
  };
  var kind = vopt !== undefined ? /* Opt_vopt */({
        _0: str_of_pp(print, Caml_option.valFromOption(vopt))
      }) : /* Opt */1;
  var a$1 = Cmdliner_info.arg_make_opt(absent, kind, a);
  var convert = function (ei, cl) {
    var match = Cmdliner_cline.opt_arg(cl, a$1);
    if (!match) {
      return try_env(ei, a$1, parse, v);
    }
    var match$1 = match.hd;
    var v$1 = match$1[2];
    var f = match$1[1];
    if (v$1 !== undefined) {
      if (!match.tl) {
        try {
          return {
                  TAG: /* Ok */0,
                  _0: parse_opt_value(parse, f, v$1)
                };
        }
        catch (raw_e){
          var e = Caml_js_exceptions.internalToOCamlException(raw_e);
          if (e.RE_EXN_ID === "Failure") {
            return {
                    TAG: /* Error */1,
                    _0: {
                      NAME: "Parse",
                      VAL: e._1
                    }
                  };
          }
          throw e;
        }
      }
      
    } else if (!match.tl) {
      if (vopt !== undefined) {
        return {
                TAG: /* Ok */0,
                _0: Caml_option.valFromOption(vopt)
              };
      }
      var e$1 = Cmdliner_msg.err_opt_value_missing(f);
      return {
              TAG: /* Error */1,
              _0: {
                NAME: "Parse",
                VAL: e$1
              }
            };
    }
    var e$2 = Cmdliner_msg.err_opt_repeated(match.tl.hd[1], f);
    return {
            TAG: /* Error */1,
            _0: {
              NAME: "Parse",
              VAL: e$2
            }
          };
  };
  return [
          Curry._1(arg_to_args, a$1),
          convert
        ];
}

function opt_all(vopt, param, v, a) {
  var parse = param[0];
  if (Cmdliner_info.arg_is_pos(a)) {
    return Pervasives.invalid_arg(err_not_opt);
  }
  var absent = /* Val */{
    _0: {
      LAZY_DONE: true,
      VAL: ""
    }
  };
  var kind = vopt !== undefined ? /* Opt_vopt */({
        _0: str_of_pp(param[1], Caml_option.valFromOption(vopt))
      }) : /* Opt */1;
  var a$1 = Cmdliner_info.arg_make_opt_all(absent, kind, a);
  var convert = function (ei, cl) {
    var l = Cmdliner_cline.opt_arg(cl, a$1);
    if (!l) {
      return try_env(ei, a$1, (function (param) {
                    return parse_to_list(parse, param);
                  }), v);
    }
    var parse$1 = function (param) {
      var v = param[2];
      var f = param[1];
      var k = param[0];
      if (v !== undefined) {
        return [
                k,
                parse_opt_value(parse, f, v)
              ];
      } else if (vopt !== undefined) {
        return [
                k,
                Caml_option.valFromOption(vopt)
              ];
      } else {
        return Pervasives.failwith(Cmdliner_msg.err_opt_value_missing(f));
      }
    };
    try {
      return {
              TAG: /* Ok */0,
              _0: List.rev_map((function (prim) {
                      return prim[1];
                    }), List.sort(rev_compare, List.rev_map(parse$1, l)))
            };
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === "Failure") {
        return {
                TAG: /* Error */1,
                _0: {
                  NAME: "Parse",
                  VAL: e._1
                }
              };
      }
      throw e;
    }
  };
  return [
          Curry._1(arg_to_args, a$1),
          convert
        ];
}

function parse_pos_value(parse, a, v) {
  var match = Curry._1(parse, v);
  if (match.NAME === "Error") {
    return Pervasives.failwith(Cmdliner_msg.err_pos_parse(a, match.VAL));
  } else {
    return match.VAL;
  }
}

function pos($staropt$star, k, param, v, a) {
  var print = param[1];
  var parse = param[0];
  var rev = $staropt$star !== undefined ? $staropt$star : false;
  if (Cmdliner_info.arg_is_opt(a)) {
    return Pervasives.invalid_arg(err_not_pos);
  }
  var absent = /* Val */{
    _0: {
      LAZY_DONE: false,
      VAL: (function () {
          return str_of_pp(print, v);
        })
    }
  };
  var pos$1 = Cmdliner_info.pos(rev, k, 1);
  var a$1 = Cmdliner_info.arg_make_pos_abs(absent, pos$1, a);
  var convert = function (ei, cl) {
    var match = Cmdliner_cline.pos_arg(cl, a$1);
    if (!match) {
      return try_env(ei, a$1, parse, v);
    }
    if (match.tl) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "cmdliner_arg.ml",
              225,
              9
            ],
            Error: new Error()
          };
    }
    try {
      return {
              TAG: /* Ok */0,
              _0: parse_pos_value(parse, a$1, match.hd)
            };
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === "Failure") {
        return {
                TAG: /* Error */1,
                _0: {
                  NAME: "Parse",
                  VAL: e._1
                }
              };
      }
      throw e;
    }
  };
  return [
          Curry._1(arg_to_args, a$1),
          convert
        ];
}

function pos_list(pos, param, v, a) {
  var parse = param[0];
  if (Cmdliner_info.arg_is_opt(a)) {
    return Pervasives.invalid_arg(err_not_pos);
  }
  var a$1 = Cmdliner_info.arg_make_pos(pos, a);
  var convert = function (ei, cl) {
    var l = Cmdliner_cline.pos_arg(cl, a$1);
    if (!l) {
      return try_env(ei, a$1, (function (param) {
                    return parse_to_list(parse, param);
                  }), v);
    }
    try {
      return {
              TAG: /* Ok */0,
              _0: List.rev(List.rev_map((function (param) {
                          return parse_pos_value(parse, a$1, param);
                        }), l))
            };
    }
    catch (raw_e){
      var e = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e.RE_EXN_ID === "Failure") {
        return {
                TAG: /* Error */1,
                _0: {
                  NAME: "Parse",
                  VAL: e._1
                }
              };
      }
      throw e;
    }
  };
  return [
          Curry._1(arg_to_args, a$1),
          convert
        ];
}

var all = Cmdliner_info.pos(false, 0, undefined);

function pos_all(c, v, a) {
  return pos_list(all, c, v, a);
}

function pos_left(revOpt, k) {
  var rev = revOpt !== undefined ? revOpt : false;
  var start = rev ? k + 1 | 0 : 0;
  var len = rev ? undefined : k;
  var partial_arg = Cmdliner_info.pos(rev, start, len);
  return function (param, param$1, param$2) {
    return pos_list(partial_arg, param, param$1, param$2);
  };
}

function pos_right(revOpt, k) {
  var rev = revOpt !== undefined ? revOpt : false;
  var start = rev ? 0 : k + 1 | 0;
  var len = rev ? k : undefined;
  var partial_arg = Cmdliner_info.pos(rev, start, len);
  return function (param, param$1, param$2) {
    return pos_list(partial_arg, param, param$1, param$2);
  };
}

function absent_error(args) {
  var make_req = function (a, acc) {
    var req_a = Cmdliner_info.arg_make_req(a);
    return Curry._2(Cmdliner_info.Args.add, req_a, acc);
  };
  return Curry._3(Cmdliner_info.Args.fold, make_req, args, Cmdliner_info.Args.empty);
}

function value(a) {
  return a;
}

function err_arg_missing(args) {
  var e = Cmdliner_msg.err_arg_missing(Curry._1(Cmdliner_info.Args.choose, args));
  return {
          TAG: /* Error */1,
          _0: {
            NAME: "Parse",
            VAL: e
          }
        };
}

function required(param) {
  var convert = param[1];
  var args = absent_error(param[0]);
  var convert$1 = function (ei, cl) {
    var e = Curry._2(convert, ei, cl);
    if (e.TAG) {
      return e;
    }
    var v = e._0;
    if (v !== undefined) {
      return {
              TAG: /* Ok */0,
              _0: Caml_option.valFromOption(v)
            };
    } else {
      return err_arg_missing(args);
    }
  };
  return [
          args,
          convert$1
        ];
}

function non_empty(param) {
  var convert = param[1];
  var args = absent_error(param[0]);
  var convert$1 = function (ei, cl) {
    var l = Curry._2(convert, ei, cl);
    if (l.TAG) {
      return l;
    }
    var l$1 = l._0;
    if (l$1) {
      return {
              TAG: /* Ok */0,
              _0: l$1
            };
    } else {
      return err_arg_missing(args);
    }
  };
  return [
          args,
          convert$1
        ];
}

function last(param) {
  var convert = param[1];
  var args = param[0];
  var convert$1 = function (ei, cl) {
    var l = Curry._2(convert, ei, cl);
    if (l.TAG) {
      return l;
    }
    var l$1 = l._0;
    if (l$1) {
      return {
              TAG: /* Ok */0,
              _0: List.hd(List.rev(l$1))
            };
    } else {
      return err_arg_missing(args);
    }
  };
  return [
          args,
          convert$1
        ];
}

var man_fmts = {
  hd: [
    "auto",
    "Auto"
  ],
  tl: {
    hd: [
      "pager",
      "Pager"
    ],
    tl: {
      hd: [
        "groff",
        "Groff"
      ],
      tl: {
        hd: [
          "plain",
          "Plain"
        ],
        tl: /* [] */0
      }
    }
  }
};

var man_fmt_docv = "FMT";

var man_fmts_enum = Cmdliner_base.$$enum(man_fmts);

var man_fmts_alts = doc_alts_enum(undefined, man_fmts);

function man_fmts_doc(kind) {
  return Curry._2(Printf.sprintf(/* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Show ",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: " in format $(docv). The value $(docv) must be ",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: ". With `auto',\n        the format is `pager` or `plain' whenever the $(b,TERM) env var is\n        `dumb' or undefined.",
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  },
                  _1: "Show %s in format $(docv). The value $(docv) must be %s. With `auto',\n        the format is `pager` or `plain' whenever the $(b,TERM) env var is\n        `dumb' or undefined."
                }), kind, man_fmts_alts);
}

var doc = man_fmts_doc("output");

var man_format = opt(undefined, man_fmts_enum, "Pager", Cmdliner_info.arg(undefined, man_fmt_docv, doc, undefined, {
          hd: "man-format",
          tl: /* [] */0
        }));

function stdopt_version(docs) {
  return flag(Cmdliner_info.arg(docs, undefined, "Show version information.", undefined, {
                  hd: "version",
                  tl: /* [] */0
                }));
}

function stdopt_help(docs) {
  var doc = man_fmts_doc("this help");
  var partial_arg = Cmdliner_base.some(undefined, man_fmts_enum);
  var partial_arg$1 = "Auto";
  var param = Cmdliner_info.arg(docs, man_fmt_docv, doc, undefined, {
        hd: "help",
        tl: /* [] */0
      });
  return opt(partial_arg$1, partial_arg, undefined, param);
}

var some = Cmdliner_base.some;

var env_var = Cmdliner_info.env;

var info = Cmdliner_info.arg;

var bool = Cmdliner_base.bool;

var $$char = Cmdliner_base.$$char;

var $$int = Cmdliner_base.$$int;

var nativeint = Cmdliner_base.nativeint;

var int32 = Cmdliner_base.int32;

var int64 = Cmdliner_base.int64;

var $$float = Cmdliner_base.$$float;

var string = Cmdliner_base.string;

var $$enum = Cmdliner_base.$$enum;

var file = Cmdliner_base.file;

var dir = Cmdliner_base.dir;

var non_dir_file = Cmdliner_base.non_dir_file;

var list = Cmdliner_base.list;

var array = Cmdliner_base.array;

var pair = Cmdliner_base.pair;

var t2 = Cmdliner_base.t2;

var t3 = Cmdliner_base.t3;

var t4 = Cmdliner_base.t4;

var doc_quote = Cmdliner_base.quote;

var doc_alts = Cmdliner_base.alts_str;

exports.conv = conv;
exports.pconv = pconv;
exports.conv_parser = conv_parser;
exports.conv_printer = conv_printer;
exports.conv_docv = conv_docv;
exports.parser_of_kind_of_string = parser_of_kind_of_string;
exports.some = some;
exports.env_var = env_var;
exports.info = info;
exports.$amp = $amp;
exports.flag = flag;
exports.flag_all = flag_all;
exports.vflag = vflag;
exports.vflag_all = vflag_all;
exports.opt = opt;
exports.opt_all = opt_all;
exports.pos = pos;
exports.pos_all = pos_all;
exports.pos_left = pos_left;
exports.pos_right = pos_right;
exports.value = value;
exports.required = required;
exports.non_empty = non_empty;
exports.last = last;
exports.man_format = man_format;
exports.stdopt_version = stdopt_version;
exports.stdopt_help = stdopt_help;
exports.bool = bool;
exports.$$char = $$char;
exports.$$int = $$int;
exports.nativeint = nativeint;
exports.int32 = int32;
exports.int64 = int64;
exports.$$float = $$float;
exports.string = string;
exports.$$enum = $$enum;
exports.file = file;
exports.dir = dir;
exports.non_dir_file = non_dir_file;
exports.list = list;
exports.array = array;
exports.pair = pair;
exports.t2 = t2;
exports.t3 = t3;
exports.t4 = t4;
exports.doc_quote = doc_quote;
exports.doc_alts = doc_alts;
exports.doc_alts_enum = doc_alts_enum;
/* all Not a pure module */
